[
  {
    "id": 1,
    "subject": "SQL",
    "category": "DB基礎知識",
    "question": "構造化問合せ言語（SQL）に関して正しい記述はどれですか。",
    "choices": [
      "SQLは階層型データベースに適した言語である",
      "複数の表からデータを結合して抽出するには、SQL文中でそれぞれのROWIDを指定する必要がある。",
      "SQLの特徴として、データを論理的に処理することができ、検索方法を指定する必要はない。",
      "SQLはネットワーク型データベースに適した言語である。"
    ],
    "answer": ["SQLの特徴として、データを論理的に処理することができ、検索方法を指定する必要はない。"],
    "explanation": "SQLは、リレーショナルデータベースを操作するための言語です。\n「ROWID」とは、行データの位置情報のことです。SQLでは、行データの位置情報を指定しなくても、適切にデータを処理できます。\nSQLでは、データ配置の詳細やアクセス手順（検索方法）を意識する必要がありません。表やキーといった論理データ構造を理解していれば、適切にデータを処理できます。",
    "type": "single"
  },
  {
    "id": 2,
    "subject": "SQL",
    "category": "演算",
    "question": "算術演算子の優先順位のルールについて正しい記述はどれですか。",
    "choices": [
      "( )と{ }と[ ]を使用して、式内の算術演算子のデフォルトの優先順位を変更できる。",
      "NULLは式内の算術演算子の優先順位に影響を与える。",
      " + と - のみを含む式では、カッコがない場合、+ が優先される。",
      "優先度が等しい算術演算子は、カッコがない場合、左から右に評価される。"
    ],
    "answer": [
      "優先度が等しい算術演算子は、カッコがない場合、左から右に評価される。"
    ],
    "explanation": "1 つの式に複数の算術演算子が使用されている場合の評価ルールは、通常の数式計算と同じです。具体的には、以下のルールに従います。\n\n・優先順位が高い算術演算子（「*」、「/」）が先に評価されます。\n・優先順位が同じ算術演算子については左（最初）から順に評価されます。\n・式の一部をカッコ（「(」、「)」）で括ると、優先順位を高くできます。",
    "type": "single"
  },
  {
    "id": 3,
    "subject": "SQL",
    "category": "DML",
    "question": "データ操作言語(DML)について正しい記述はどれですか(2つ選択してください)。",
    "choices": [
      "1つのUPDATE文で複数の列の値をまとめて更新することはできない。",
      "1つのUPDATE文のSET句に複数の副問合せを書くことができる。",
      "INSERT文でNULL値を明示的に挿入することはできない。",
      "INSERT文で明示的に値を設定しなかった列には、デフォルト値もしくはNULL値が挿入される。",
      "DELETE文でWHERE句を書かないと1行も削除されない。"
    ],
    "answer": [
      "1つのUPDATE文のSET句に複数の副問合せを書くことができる。",
      "INSERT文で明示的に値を設定しなかった列には、デフォルト値もしくはNULL値が挿入される。"],
    "explanation": "UPDATE文のSET句に、カンマ「, 」で区切って「変更したい列名と値」を複数指定すると、一度に複数の列を変更できます。\n副問合せは、戻す行数、値の数がマッチしてさえいればどこでも指定ができます。また、埋め込むことができる副問合せの数に制約はありません。\nINSERT句に「NULL」を指定すると、NULL値を明示的に挿入できます。\nINSERT文で明示的に値を設定しなかった列には、デフォルト値もしくはNULL値が挿入されます。\nDELETE文でWHERE句を省略すると、すべての行が削除されます。",
    "type": "multiple"
  },
  {
    "id": 4,
    "subject": "SQL",
    "category": "データ型",
    "question": "NUMBER(5,3)として定義した列に値を挿入します。エラーにならずに挿入できる値はどれですか(3つ選択してください)。",
    "choices": [
      "12345",
      "123.45",
      "12.3456",
      "1.2345",
      "1.23456"
    ],
    "answer": [
      "12.3456",
      "1.2345",
      "1.23456"
    ],
    "explanation": "NUMBER(5,3)は、整数部分の最大桁数が2(=5-3)、小数点以下の最大桁数が3です。\nNUMBER(n,m)と表した時、mの数値を超えた場合は四捨五入が行われエラーは発生しません。",
    "type": "multiple"
  },
  {
    "id": 5,
    "subject": "SQL",
    "category": "データ型",
    "question": "次の問合せを確認してください。\n\nSELECT CONCAT(first_name, CONCAT(salary, hire_date)) FROM employees;\n\n正しい記述はどれですか。",
    "choices": [
      "データ型は暗黙変換され、正常に実行される。",
      "ファンクションはネストできないのでエラーになる。",
      "データ型が揃っていないのでエラーになる。",
      "TO_CHAR変換ファンクションを入れる必要がある。"
    ],
    "answer": [
      "データ型は暗黙変換され、正常に実行される。"
    ],
    "explanation": "CONCATファンクションは、文字列を連結する単一行ファンクションです。\n単一行ファンクションは何段階でもネストが可能です。\nsalaryは数値型で、hire_dateは日時型ですが、文字列に暗黙的に変換され、文字列連携が実行されます。(特定のデータ型を想定している箇所で、別のデータ型のデータを受け取ったときに、想定されるデータ型への自動的な変換を「暗黙的なデータ型変換」といいます。)\nTO_CHARファンクションを使用して明示的に変換を行うことも可能ですが、暗黙的変換が機能するため必須ではありません。",
    "type": "single"
  },
  {
    "id": 6,
    "subject": "SQL",
    "category": "DML",
    "question": "複数表のINSERT 文（マルチテーブル・インサート）に関して正しい記述はどれですか。",
    "choices": [
      "インサート対象として、ビューを指定することはできない。",
      "インサート対象として、索引構成表を指定することはできない。",
      "副問合せの対象として、ビューを指定することはできない。",
      "副問合せの対象として、索引構成表を指定することはできない。"
    ],
    "answer": [
      "インサート対象として、ビューを指定することはできない。"
      ],
    "explanation": "マルチテーブルINSERTで行をINSERTできるのは表のみです。ビューにはINSERTできません。また、リモート表にもINSERTは不可能です。\n索引構成表は表の一種です。索引構成表にマルチテーブルINSERTで行をINSERTできます。\nマルチテーブルINSERTにおける副問合せについて、ビューや索引構成表を指定できないというような制約はありません。",
    "type": "single"
  },
  {
    "id": 7,
    "subject": "SQL",
    "category": "DML",
    "question": "MERGE文に関して正しい記述はどれですか。",
    "choices": [
      "USING句に副問合せを指定できる。",
      "ON句は省略可能である。",
      "WHEN MATCHED句にINSERTを指定できる。",
      "INTO句に複数のターゲット表を指定すると、複数の表をまとめて更新できる。"
    ],
    "answer": [
      "USING句に副問合せを指定できる。"
    ],
    "explanation": "MERGE文のUSING句にはソース表の表名を指定します。ただし、表の代わりにビューや副問合せを指定することもできます。\nON句にはソース表の行に対応するターゲット表の行を対応付けるための条件を指定します。ON句は省略できません。\nWHEN MATCHED句に指定するのはUPDATEです。INSERTは、WHEN NOT MATCHED句に指定します。\nINTO句にはターゲット表の表名を指定します。複数の表を指定することはできません。",
    "type": "single"
  },
  {
    "id": 8,
    "subject": "SQL",
    "category": "索引・シノニム・シーケンス",
    "question": "次のコマンドを実行しました。\n\nCREATE SEQUENCE orders_seq\nINCREMENT BY 10\nSTART WITH 100\nMAXVALUE 100000\nNOCYCLE\nCACHE 10;\n\norders_seqシーケンスについて正しい説明はどれですか。",
    "choices": [
      "新しいシーケンス値を発番するには、orders_seq.CURRVALを参照する。",
      "最大値の100000までいくと、100に戻って、シーケンスが生成される。",
      "10から始まり、100ずつ増えるシーケンス値が生成される。",
      "シーケンス値はキャッシュされ、スムーズに発行される。"
    ],
    "answer": [
      "シーケンス値はキャッシュされ、スムーズに発行される。"
    ],
    "explanation": "シーケンスから新たに連番を振り出すには、シーケンスのNEXTVAL を参照します。\nすでに振り出された連番を確認するには、シーケンスのCURRVALを参照します。\n\n設問のCREATE SEQUENCE文で作成したシーケンスの特徴は以下です。\n\n・初期値は100です（「START WITH 100」)。増分値は10です(「INCREMENT BY 10」)。\n・シーケンスの値の最大値は100000 です（「MAXVALUE 100000」）。シーケンスの値が最大値に達すると、それ以上値を生成しません（「NOCYCLE」）。\n・10個のシーケンスの値をメモリー上にキャッシュします（「CACHE 10」）。",
    "type": "single"
  },
  {
    "id": 9,
    "subject": "SQL",
    "category": "索引・シノニム・シーケンス",
    "question": "シノニムについて正しい記述はどれですか（3 つ選択してください）。",
    "choices": [
      "プライベートシノニムには、同じスキーマにある他のオブジェクトの名前と同じ名前を付けることができる。",
      "シーケンスやビュー、別のシノニムに対してシノニムを作成できる。",
      "プライベートシノニムはセグメントを持つ。",
      "SQLの中でスキーマ名を指定せずに表にアクセスするためにシノニムを使うことがある。",
      "参照しているオブジェクトが削除されると、シノニムも自動的に削除される。",
      "PUBLICシノニムを作成するには、CREATE PUBLIC SYNONYMシステム権限が必要である。"
    ],
    "answer": [
      "シーケンスやビュー、別のシノニムに対してシノニムを作成できる。",
      "SQLの中でスキーマ名を指定せずに表にアクセスするためにシノニムを使うことがある。",
      "PUBLICシノニムを作成するには、CREATE PUBLIC SYNONYMシステム権限が必要である。"],
    "explanation": "シノニムとは、オブジェクトに付ける別名です。表やビュー、シーケンス、プロシージャ、パッケージなどの様々なオブジェクトに対して、シノニムを定義して別名を付けることができます。シノニムに対してシノニムを作成することもできます。\n他のスキーマ内のオブジェクト（< スキーマ名>.< オブジェクト名>）や、データベースリンクを経由してアクセスするリモートオブジェクト（<オブジェクト名>@）に、「短い別名」を付けるためシノニムを使うことがあります。\nパブリックシノニムを作成するには、CREATE PUBLIC SYNONYMシステム権限が必要です。\nシノニムはデータを格納しないため、対応するセグメントを持ちません。\nシノニムが参照しているオブジェクトを削除しても、そのオブジェクトを参照していたシノニムはそのままです。\n一部の例外を除き、特定のスキーマにあるオブジェクトは、同じ名前を付けられません。以下のオブジェクトは、オブジェクトの種類が違えば同じ名前をつけられます(名前空間が異なるため)。\n・索引\n・制約\n・トリガー",
    "type": "multiple"
  },
  {
    "id": 10,
    "subject": "SQL",
    "category": "索引・シノニム・シーケンス",
    "question": "索引について正しい記述はどれですか。",
    "choices": [
      "既存の一意索引を非一意索引に変更できる。",
      "DROP TABLE文で表がRECYCLE BINに移ると、その表に定義されていた索引はすべてUNUSABLEになる。",
      "表と索引は常に同じスキーマに属するとは限らない。",
      "索引列の列値を更新した後、それを索引エントリに反映するには手動で再構築する必要がある。"
    ],
    "answer": [
      "表と索引は常に同じスキーマに属するとは限らない。"
    ],
    "explanation": "索引を設定した表と、索引を別のスキーマに格納することもできます。\n既存の一意索引を非一意索引に変更できません。索引を再作成する必要があります。\nOracleには「ごみ箱」という機能があり、削除した表はごみ箱（RECYCLE BIN）に入ります。表に索引が設定されている場合、索引も一緒にごみ箱に入ります。UNUSABLEになるわけではありません。\n行の索引列を更新すると、Oracleにより自動的に索引のメンテナンス処理（内部的な変更処理）が実行されます。",
    "type": "single"
  }
]
